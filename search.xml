<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Delta Lake 全面解析</title>
      <link href="/posts/36c8/"/>
      <url>/posts/36c8/</url>
      
        <content type="html"><![CDATA[<p>Delta Lake 在 Spark + AI Summit 2019 宣布开源，引起了不小的震动，这到底是何方神圣？本文将从什么是 Delta Lake、它有那些特点、它是如何实现的，以及它的出现对未来大数据领域和大数据从业者可能有什么影响这些角度，全面解析这一新一代的文件存储层。</p><a id="more"></a><h1 id="delta-lake"><a class="markdownIt-Anchor" href="#delta-lake"></a> Delta Lake</h1><p><a href="https://delta.io/" rel="external nofollow noopener noreferrer" target="_blank">Delta Lake</a> 是 Databricks (俗称&quot;砖厂&quot;) 开源的一个文件存储层,目前运行在 Spark 上。它主要提供了以下功能（摘自官网）：</p><ol><li>ACID 事务(ACID transactions)</li><li>Schema 相关特性：Schema 本地存储、支持 Schema 约束、Schema 演变 (Scalable Metadata Handling、Schema Enforcement、Schema Evolution)</li><li>数据版本控制 (Time Travel (data versioning))</li><li>支持数据更新删除 （Updates and Deletes）</li><li>统一了流数据和批处理数据落地 (Unified batch and streaming sink)</li></ol><h1 id="特性的详细介绍"><a class="markdownIt-Anchor" href="#特性的详细介绍"></a> 特性的详细介绍</h1><p>下面将会对Delta Lake 的特性详细介绍。</p><h2 id="acid-事务"><a class="markdownIt-Anchor" href="#acid-事务"></a> ACID 事务</h2><p>这里的 ACID 就是指原子性、一致性、隔离性和持久性。一致性、持久性之前就已经实现，这里主要是解释一下原子性和隔离性。<br>原子性：一个事务要么成功要么失败，不存在中间状态。这一个特性对于数据的准确性，特别是出现失败时候仍然保持准确性至关重要。当 job 失败时已经写入的数据会自动回滚到未写入的状态，不需要手工处理。<br>隔离性：基于<a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control" rel="external nofollow noopener noreferrer" target="_blank">乐观的并发控制</a>实现可序列花的隔离级别。乐观的并发控制在竞争不很激烈的情况下，会提高性能。可序列花的隔离级别保证了即使并发执行读或写操作，仍然保证像在串行读写一样。<br>具体的，Delta Lake 支持并发读取、并发追加(追加的内容不依赖于任何的读取已经存在的数据)，但不支持并发修改，出现并发修改会抛出 concurrent modification exception。<br>隔离性保证无论是并发批处理操作、流操作或者是批流并发操作，数据都是准确的</p><h2 id="schema-相关特性"><a class="markdownIt-Anchor" href="#schema-相关特性"></a> Schema 相关特性</h2><p>Hive Metastore 一般用中心化的存储（如 MySQL） 对 Schema 进行管理。在 Schema 数量特别巨大时(比如分区数特别多)，由于中心化存储伸缩性是非线性的，容易形成瓶颈。<br>Delta Lake 将元数据同样视为数据，保存在文件中，使得对大数据的处理能力可以运用在处理元数据上。<br>由于元数据由文件进行管理，所以有了更大的灵活性和可能性，Schema Enforcement （强制检验数据的 Schema，不通过则拒绝），Schema Evolution （根据数据自动更改 Schema，无需手动指定）</p><h2 id="数据版本控制"><a class="markdownIt-Anchor" href="#数据版本控制"></a> 数据版本控制</h2><p>事务都有了，实现版本控制也是顺带的事。Delta Lake 可以将读取和恢复数据到某一个历史版本。</p><h2 id="支持数据更新删除"><a class="markdownIt-Anchor" href="#支持数据更新删除"></a> 支持数据更新删除</h2><p>支持包括单条数据、批量数据的更新和删除</p><h2 id="统一了流数据和批处理数据落地"><a class="markdownIt-Anchor" href="#统一了流数据和批处理数据落地"></a> 统一了流数据和批处理数据落地</h2><p>Delta Lake 还统一了流数据和批处理数据落地，而不需要最开始提到的 Lambda 架构。极大的简化了系统的复杂性</p><h1 id="delta-lake-快速体验"><a class="markdownIt-Anchor" href="#delta-lake-快速体验"></a> Delta  Lake 快速体验</h1><p>使用 Delta Lake 需要 Spark  2.4.2 及以上版本，如果仅仅想体验一下，可以使用 Docker 版 Spark</p><ul><li>安装 Spark</li></ul><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name spark-master -h spark-master \<br>-p 8080:8080 \<br>-p 7077:7077 \<br>-p 4040:4040  \<br>-e ENABLE_INIT_DAEMON=<span class="hljs-literal">false</span>  \<br>bde2020/spark-master:2.4.3-hadoop2.7<br><br><br>docker run -d --name spark-worker-1 \<br>-p 8081:8081 \<br>--link spark-master:spark-master \<br>-e ENABLE_INIT_DAEMON=<span class="hljs-literal">false</span> \<br>bde2020/spark-worker:2.4.3-hadoop2.7<br></code></pre></td></tr></table></figure><ul><li>进入 Spark Shell</li></ul><figure class="hljs highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it spark-master  /spark/bin/spark-shell --packages io.delta:delta-core_2.11:0.3.0<br></code></pre></td></tr></table></figure><ul><li>创建 Delta Table</li></ul><figure class="hljs highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">val</span> data = spark.range(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br>data.write.format(<span class="hljs-string">"delta"</span>).save(<span class="hljs-string">"/tmp/delta-table"</span>)<br></code></pre></td></tr></table></figure><ul><li>其他更多实践请参阅 <a href="https://docs.delta.io/latest/quick-start.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a></li></ul><h1 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h1><h2 id="delta-lake-的文件结构"><a class="markdownIt-Anchor" href="#delta-lake-的文件结构"></a> Delta Lake 的文件结构</h2><p>Delta Lake 在原有的 Parquet 文件的基础上，增加了 _delta_log 文件夹。_delta_log 文件夹内包含 json 文件和 checkpoint.parquet 文件。<br><img src="/images/delta-lake-folder.jpg" alt="_delta_log 结构"></p><ul><li>这些 json 文件称为 transaction log,文件名是递增的，每一个文件代表一个事务,存储了 Schema 信息，对文件的操作等</li></ul><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;"commitInfo":&#123;"timestamp":1563414817197,"operation":"WRITE","operationParameters":&#123;"mode":"ErrorIfExists","partitionBy":"[]"&#125;,"isBlindAppend":true&#125;&#125;<br>&#123;"protocol":&#123;"minReaderVersion":1,"minWriterVersion":2&#125;&#125;<br>&#123;"metaData":&#123;"id":"72e1fda6-6860-477a-94bf-924c5935818b","format":&#123;"provider":"parquet","options":&#123;&#125;&#125;,"schemaString":"&#123;\"type\":\"struct\",\"fields\":[&#123;\"name\":\"id\",\"type\":\"long\",\"nullable\":true,<br>\"metadata\":&#123;&#125;&#125;]&#125;","partitionColumns":[],"configuration":&#123;&#125;,"createdTime":1563414816435&#125;&#125;<br>&#123;"add":&#123;"path":"part-00000-90a5fe90-b039-4cce-92be-ff70abc6aeac-c000.snappy.parquet","partitionValues":&#123;&#125;,"size":263,"modificationTime":1563414816000,"dataChange":true&#125;&#125;<br></code></pre></td></tr></table></figure><ul><li>checkpoint.parquet 是检查点，可以加速数据的读取</li></ul><p>在<strong>没有检查点的情况下</strong> ，需要从头开始读取 transaction log，重放每一个 transaction log 的文件操作，才会得到所需要的结果，有了检查点，获取数据的某一个版本时，只需要从距离版本最近的检查点，重放版本和检查点的 transaction log 即可得到指定版本的数据</p><h2 id="实现原子操作"><a class="markdownIt-Anchor" href="#实现原子操作"></a> 实现原子操作</h2><p><strong>写入失败时：</strong> 事务不提交，不形成 transaction log 文件，本次事务写入的文件就不会纳入到当前表中。<br><strong>写入成功时：</strong> 事务提交，transaction log 原子的生成，于是数据变持久性存在于当前 delta table 中</p><h2 id="实现可序列化隔离级别"><a class="markdownIt-Anchor" href="#实现可序列化隔离级别"></a> 实现可序列化隔离级别</h2><p>可序列化隔离的实现基于<a href="https://zh.wikipedia.org/zh-hans/%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" rel="external nofollow noopener noreferrer" target="_blank">乐观并发控制</a><br><strong>并发修改的情况：</strong> 事务开始是读取最新版本的数据，输出数据产生一个新的版本，在事务提交之前，检查是否还有其他提交的 transaction log 与本次提交有冲突，如果有冲突，抛出 ConcurrentModificationException。写入的数据不会提交，因此不会生效<br><strong>并发追加的情况：</strong> 与之类似，不同点在于发现冲突时会检查 Schema 是否变化，如果没有变化，会自动重试，不会抛出异常</p><h1 id="关于-delta-lake-的思考"><a class="markdownIt-Anchor" href="#关于-delta-lake-的思考"></a> 关于 Delta Lake 的思考</h1><p>像 Delta Lake、 Netflix 的 iceberg 这种新一代的文件格式的出现，解决了大数据发展中批流存储不统一、不支持事务等等痛点。</p><p>Spark 诞生之初，就在计算模型上实现了批处理和流处理的统一，现在 Delta Lake 的出现，在存储层也将实现统一。<br>批流处理的大一统后不但意味着可以消除像 Lambda 架构这种变通的解决方案，而且目前常用的基于批处理的数据加工方式也可也会被流式的数据处理方式所取代。再加上可以支持事务。</p><p>届时，开发者可以把更多精力放在&quot;如何从数据中提取有用的信息&quot;这样一件事情上，更多的关注数据流应该如何变化，而不是关注任务说明时候执行，任务失败了怎么重试等等问题。</p><p>所以像 Lambda 架构、各种数据准确性检验任务、不同系统的数据导入工具、调度执行批处理任务等等，这些在大数据领域习以为常的解决方案会成为历史。</p><p>一方面这当然是好事，开发者可以各司其职，大数据系统也会更加统一<br>但另一方面，技术的升级往往会替代一部分人，而且会让我们之前的经验一文不值。所以需要我们更需要思考如何提升自己，让自己驾驭技术，而不是让技术取代自己，就像很多职业都需要自思考如何被人工智能取代一样。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Spark </tag>
            
            <tag> Delta Lake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda 架构</title>
      <link href="/posts/9ee5/"/>
      <url>/posts/9ee5/</url>
      
        <content type="html"><![CDATA[<p><em>Lambda 架构</em> 是大数据量下的一种数据处理的架构，它同时使用批处理和流处理的方法处理大量数据。</p><a id="more"></a><h1 id="lambda-架构"><a class="markdownIt-Anchor" href="#lambda-架构"></a> Lambda 架构</h1><h2 id="什么是-lambda-架构"><a class="markdownIt-Anchor" href="#什么是-lambda-架构"></a> 什么是 Lambda 架构</h2><p><em>Lambda 架构</em> 是大数据量下的一种数据处理的架构，它同时使用批处理和流处理的方法处理大量数据。<br><img src="/images/15649951835087.jpg" alt="Lambda 架构"></p><p>标准的 Lambda 架构包含 batch layer(批处理层)、serving layer（服务层）、speed layer(实时层)</p><ul><li>批处理层：包含 master dataset(存储全量数据) 和 batch view (预计算结果)</li><li>实时层：由于批处理层数据处理存在延时，如果想获得实时数据，需要实时层的支撑。一般使用实时计算引擎（如 Spark Streaming、Flink）完成计算</li><li>服务层：对最终结果的查询提供支撑，合并批处理层、实时层结果。 一般使用 NoSQL 数据库存储，如 HBase</li></ul><h2 id="lambda-架构解决的问题"><a class="markdownIt-Anchor" href="#lambda-架构解决的问题"></a> Lambda 架构解决的问题</h2><p>Lambda 架构将两种异构的系统整合，实现了既能分又析历史数据，又能计算实时数据。历史数据保存了所有的明细，可以使用多变的方式分析；实时数据包含最新的信息，可以提供报警、及时分析等能力</p><h2 id="lambda-架构不足"><a class="markdownIt-Anchor" href="#lambda-架构不足"></a> Lambda 架构不足</h2><p>由于实时层和批处理层使用的是不同架构的系统，因此需要对应开发不同的代码，而且需要对同样的数据处理两次：开发者需要熟悉不同的组件、需要维护数据的一致性，都是比较复杂的。<br>本文的主角 Delta Lake 解决了历史数据和实时数据需要不同系统处理的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基准测试(Benchmark) JMH 实战篇</title>
      <link href="/posts/9cee/"/>
      <url>/posts/9cee/</url>
      
        <content type="html"><![CDATA[<p>上一篇文章介绍了基准测试的基本概念以及 Java性能测试工具 JMH 的简单使用。这一篇文章将通过实例详细介绍 JMH 的使用方法，并验证几个提高程序性能的方式是否正确并给出作者的结论。</p><a id="more"></a><h1 id="字符串拼接基准测试"><a class="markdownIt-Anchor" href="#字符串拼接基准测试"></a> 字符串拼接基准测试</h1><p>Java 中有这样一条优化建议，在循环中使用”+“号拼接字符串会带来很大的性能损失，应该使用StringBuilder。</p><p>这样的建议是否准确呢？我们可以设计基准测试来验证，使用的当然是我们的主角 JMH，下面是代码实现 (源码可以在 GitHub 上查看：<a href="https://github.com/KevinZhangMe/jmh-demo" rel="external nofollow noopener noreferrer" target="_blank">地址</a>)</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Benchmark;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.BenchmarkMode;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Mode;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.OutputTimeUnit;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.Runner;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.RunnerException;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.Options;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;<br><br><span class="hljs-comment">/**<br> * 字符串拼接基准测试<br> *<br> * 测试结果：<br> * &lt;pre&gt;<br> * Benchmark                                         Mode  Cnt   Score    Error  Units<br> * StringAppendBenchmarkTenK.stringAddBenchmark      avgt   25  82.590 ± 14.824  ms/op<br> * StringAppendBenchmarkTenK.stringBufferBenchmark   avgt   25   0.127 ±  0.005  ms/op<br> * StringAppendBenchmarkTenK.stringBuilderBenchmark  avgt   25   0.146 ±  0.010  ms/op<br> * &lt;/pre&gt;<br> *<br> * <span class="hljs-doctag">@author</span> KevinZhang &lt;kevin.zhang.me@gmail.com&gt;<br> */</span><br><span class="hljs-meta">@BenchmarkMode</span>(Mode.AverageTime)<br><span class="hljs-meta">@OutputTimeUnit</span>(TimeUnit.MILLISECONDS)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringAppendBenchmarkTenK</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TEN_K = <span class="hljs-number">10000</span>;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">stringAddBenchmark</span><span class="hljs-params">()</span> </span>&#123;<br>        String targetString = <span class="hljs-string">""</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TEN_K; i++) &#123;<br>            targetString += <span class="hljs-string">"hello"</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> targetString;<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">stringBuilderBenchmark</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TEN_K; i++) &#123;<br>            sb.append(<span class="hljs-string">"hello"</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">stringBufferBenchmark</span><span class="hljs-params">()</span> </span>&#123;<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; TEN_K; i++) &#123;<br>            sb.append(<span class="hljs-string">"hello"</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException </span>&#123;<br>        Options opt = <span class="hljs-keyword">new</span> OptionsBuilder()<br>                .include(StringAppendBenchmarkTenK.class.getSimpleName())<br>                .forks(<span class="hljs-number">1</span>)<br>                .build();<br><br>        <span class="hljs-keyword">new</span> Runner(opt).run();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到有几个注解:</p><p>@BenchmarkMode 代表基准测试模式，包含</p><ul><li><code>Throughput</code> 模式 ：吞吐量模式，测试单位时间内可以执行测试方法的次数（默认1秒）</li><li><code>Average Time</code> 模式：平均时间模式，测试平均每次操作需要多长时间，它的值等于 <code>Throughput</code> 模式的倒数</li><li><code>Sample Time</code>模式：时间取样模式，测试单位时间运行，自动取样执行的时间进行测量，其结果包含统计信息，比如 P99 、数据分布情况等等</li><li><code>Single Shot Time</code>模式：测试单次方法运行的时间，没有 预热阶段，适合测试冷启动所需要的时间</li><li><code>All</code>模式：同时使用以上所有模式</li></ul><p>@Benchmark 代表这个方法是一个基准测试用例，作为测试用例的入口，类似JUnit 中 @Test 注解</p><p>@OutputTimeUnit 设置输出数据的单位，此处是毫秒，加上AverageTime 模式，最后的单位是 ms/op：每次操作需要多少毫秒</p><h2 id="测试结果"><a class="markdownIt-Anchor" href="#测试结果"></a> 测试结果</h2><p>下面是在我在本地运行的结果:</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Benchmark                                         Mode  Cnt   Score    Error  Units<br>StringAppendBenchmarkTenK.stringAddBenchmark      avgt   25  82.590 ± 14.824  ms/op<br>StringAppendBenchmarkTenK.stringBufferBenchmark   avgt   25   0.127 ±  0.005  ms/op<br>StringAppendBenchmarkTenK.stringBuilderBenchmark  avgt   25   0.146 ±  0.010  ms/op<br></code></pre></td></tr></table></figure><p>我们可以看到 stringAddBenchmark 代表简单Sting 相加的方式，使用平均时间模式，平均每次执行需要82.590毫秒，误差在 ± 14.824 ms。其他两个的意义与之类似。</p><h2 id="结果分析"><a class="markdownIt-Anchor" href="#结果分析"></a> 结果分析</h2><p>从结果中我们可以看到，</p><ol><li><strong>使用简单的字符串相加比使用 StringBuffer 和 StringBuilder 慢了两个数量级；</strong></li><li><strong>StringBuilder 比 StringBuffer要慢一些；</strong></li></ol><p>结果 1 的原因是：String 在字符串拼接时，每次循环会创建新的 StringBuffer 对象(不是 String 对象)，然后把原来的对象销毁，而 StringBuffer / StringBuilder  在初始化时预留了一定的空间，在调用 append 方法时只有在预留空间不足时才会发生数组拷贝。</p><p>结果 2 的原因是：StringBuffer 是线程安全的，append  方法是加锁的；StringBuilder 是非线程安全的。两个类除了在线程安全上的区别，其他几乎没有任何差别。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringBuilder 的 toString 方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.append(str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br> &#125;<br><span class="hljs-comment">// StringBuffer 的 toString 方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="展望"><a class="markdownIt-Anchor" href="#展望"></a> 展望</h2><p>分析至此，我们还可以得出一个结论，**尽管在没有多线程竞争的情况下，加锁仍会损失一部分性能。**这个结论可以设计另一个基准测试来验证，读者有兴趣可以自己设计。</p><h1 id="线程安全的-long-类型"><a class="markdownIt-Anchor" href="#线程安全的-long-类型"></a> 线程安全的 Long 类型</h1><p>说起线程安全的 long 类型的实现，不难想到有使用悲观锁锁synchronized 、乐观锁 AtomicLong 这两种实现，有没有性能更高的实现呢？肯定是有的，java 8 中发布的 LongAdder 就是为替代 AtomicLong 而存在的。</p><p>LongAdder 原理，简单来讲就是在多线程竞争激烈的情况下，LongAdder 将维护的值分散到多个段中，来减少CAS的重试，当需要获得结果时，只需要把各个段相加就可以了（类比 ConcurrentHashMap 分段锁的实现）。与 AtomicLong 多线程 CAS 更新单个值相比，理论上性能会有提升。</p><p>下面是我设计的基准测试的用例(源码可以在 GitHub 上查看：<a href="https://github.com/KevinZhangMe/jmh-demo" rel="external nofollow noopener noreferrer" target="_blank">地址</a>)，用来验证线程安全Long类型的不同实现。</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.LongAdder;<br><br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Benchmark;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.BenchmarkMode;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Fork;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Level;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Measurement;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Mode;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.OutputTimeUnit;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Scope;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Setup;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.State;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.TearDown;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Threads;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Warmup;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.RunnerException;<br><br><span class="hljs-keyword">import</span> com.technologiesinsight.jmh.helper.LunchHelper;<br><br><br><span class="hljs-comment">/**<br> *  synchronized 锁 vs AtomicLong vs LongAdder 基准测试<br> *<br> * &lt;pre&gt;<br> * Benchmark                                  Mode  Cnt    Score    Error  Units<br> * ThreadSafeLong.testAtomicLongIncrement     avgt   25  383.194 ± 23.359  ms/op<br> * ThreadSafeLong.testLongAdderIncrement      avgt   25  108.105 ±  2.911  ms/op<br> * ThreadSafeLong.testPrimitiveLongIncrement  avgt   25  908.964 ± 29.782  ms/op<br> * &lt;/pre&gt;<br> * <span class="hljs-doctag">@author</span> KevinZhang &lt;kevin.zhang.me@gmail.com&gt;<br> */</span><br><span class="hljs-meta">@BenchmarkMode</span>(Mode.AverageTime)<br><span class="hljs-meta">@OutputTimeUnit</span>(TimeUnit.MILLISECONDS)<br><span class="hljs-comment">//@Measurement(iterations = 1, time = 1, timeUnit = TimeUnit.SECONDS)</span><br><span class="hljs-comment">//@Warmup(iterations = 0, time = 1, timeUnit = TimeUnit.SECONDS)</span><br><span class="hljs-comment">//@Fork(1)</span><br><span class="hljs-meta">@State</span>(Scope.Benchmark)<br><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unused"</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadSafeLong</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer LOOP = <span class="hljs-number">10000000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object lock = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-keyword">private</span> AtomicLong atomicLong;<br>    <span class="hljs-keyword">private</span> LongAdder longAdder;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> primitiveLong;<br><br><br>    <span class="hljs-meta">@Setup</span>(Level.Iteration)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.atomicLong = <span class="hljs-keyword">new</span> AtomicLong();<br>        <span class="hljs-keyword">this</span>.longAdder = <span class="hljs-keyword">new</span> LongAdder();<br>        <span class="hljs-keyword">this</span>.primitiveLong = <span class="hljs-number">0L</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-meta">@Threads</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">testPrimitiveLongIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; LOOP; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                primitiveLong = primitiveLong + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> primitiveLong;<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-meta">@Threads</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">testAtomicLongIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; LOOP; i++) &#123;<br>            atomicLong.incrementAndGet();<br>        &#125;<br>        <span class="hljs-keyword">return</span> atomicLong.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-meta">@Threads</span>(<span class="hljs-number">2</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">testLongAdderIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; LOOP; i++) &#123;<br>            longAdder.increment();<br>        &#125;<br>        <span class="hljs-keyword">return</span> longAdder.longValue();<br>    &#125;<br><br>    <span class="hljs-meta">@TearDown</span>(Level.Iteration)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tearDown</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> atomicResult = atomicLong.get();<br>        <span class="hljs-keyword">long</span> longAdderResult = longAdder.longValue();<br>        System.out.println(String.format(<span class="hljs-string">"primitiveLongResult is %s,atomicResult is :%s;longAdderResult is %s"</span>, primitiveLong, atomicResult, longAdderResult));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException </span>&#123;<br>        LunchHelper.lunchBenchmark(ThreadSafeLong.class);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>相比于上一个案例，我们发现了几个关于 JMH 的“新面孔”</p><ul><li>@State(Scope.Benchmark) ：有时候测试用例中需要维护一些”状态“（测试用不是一个”纯函数“），”状态“的变化可能会影响测试的结果。所以需要由JMH 管理这些状态，并显示的声明这些状态的声明周期（有效范围）。状态生命周期分为三类，由State的参数指定:<ul><li><code>Thread</code>  每一个线程创建自己的状态对象。因此共享对象不会有线程安全问题。</li><li><code>Group</code> 组内共享状态对象。不同分组可以使用  @Group(“groupName”) 指定</li><li><code>Benchmark</code>  一次迭代运行中所有的线程共享状态对象。</li></ul></li><li>@Setup(Level.Iteration) :用于执行基准测试前执行一些操作，比如初始化等等。参数 Level表示改方法说明时候执行：<ul><li><code>Trial</code> 每次一个进程完整运行一遍测试用例之前执行：包括 warmUp 和  正式执行阶段</li><li><code>Iteration</code> 每次迭代前会执行。一次完整的运行包含多次迭代过程，每次迭代运行一次测试的方法。</li><li><code>Invocation</code>  每次方法调用前会执行。</li></ul></li><li>@TearDown : 类似@Setup ,在测试后执行</li><li>@Thread :同时执行的线程数，用于线程下的基准测试</li><li>注释部分 @Measurement 等：用于测试用例开发阶段，提高执行速度，正式测试前需要注释掉</li><li><code>LunchHelper.lunchBenchmark(ThreadSafeLong.class)</code> JMH 启动助手</li></ul><h2 id="测试结果-2"><a class="markdownIt-Anchor" href="#测试结果-2"></a> 测试结果</h2><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Benchmark                                  Mode  Cnt    Score    Error  Units<br>ThreadSafeLong.testAtomicLongIncrement     avgt   25  383.194 ± 23.359  ms/op<br>ThreadSafeLong.testLongAdderIncrement      avgt   25  108.105 ±  2.911  ms/op<br>ThreadSafeLong.testPrimitiveLongIncrement  avgt   25  908.964 ± 29.782  ms/op<br></code></pre></td></tr></table></figure><p>通过基准测试结果我们可以看到，testAtomicLongIncrement 代表使用 Atomic 类完成自增，运行 25 次后，所得到每次运行平均时间是383.194 ms，误差在± 23.359ms。其他结果的意义与之类似。</p><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>从结果中可以看到，在两个线程竞争同一个 long 类型的情况下，LongAdder 性能最好名副其实，AtomicLong 次之，使用 synchronized 加锁性能最差。</p><p>在日常开发中，我们可以尝试使用 LongAdder 代替 AtomicInteger 和加锁的方式</p><h2 id="展望-2"><a class="markdownIt-Anchor" href="#展望-2"></a> 展望</h2><p>通过这个测试案例，我们可以分析出 JMH 测试框架本身的性能损耗，欢迎有兴趣的读者留言交流。</p><h1 id="其他测试案例"><a class="markdownIt-Anchor" href="#其他测试案例"></a> 其他测试案例</h1><p><a href="https://github.com/KevinZhangMe/jmh-demo" rel="external nofollow noopener noreferrer" target="_blank">源码</a> 中还有其他一些测试案例，比如</p><ul><li>常见几个Map的测试：位于 com.technologiesinsight.jmh.MapBenchmark</li></ul><h1 id="展望-3"><a class="markdownIt-Anchor" href="#展望-3"></a> 展望</h1><p>很多公司编程对测试环节于不太重视，追求的是功能快速上线。这样的做法短期内可以提高开发速度，但如果从长远来看，单元测试，基准测试等测试，会减少后期维护、功能扩展的成本；对于开发者来说，掌握基本的测试理论和实践是一项基本的能力。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> JMH </tag>
            
            <tag> 基准测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基准测试 (Benchmark) 入门篇</title>
      <link href="/posts/dfff/"/>
      <url>/posts/dfff/</url>
      
        <content type="html"><![CDATA[<p>基准测试对我们来说，一个熟悉又陌生的名字。说它熟悉的原因是它在我们生活中无处不在；说他陌生，是因为它常常以各种名字存在于我们生活中。比如”不服跑个分“,其中的“跑分”指的就是基准测试。类似的还有网速测试、Online Judge 的评测结果等等。本文将介绍部分基准测试的理论、以及 Java 官方提供的微基准测试工具的使用。</p><a id="more"></a><h1 id="什么是基准测试"><a class="markdownIt-Anchor" href="#什么是基准测试"></a> 什么是基准测试</h1><p>那么什么是基准测试呢？</p><p>简单来说，<em>基准测试</em>是为了评估测试目标的性能采取的一系列行动，包括运行一个或一组程序或者执行其他的操作。[1]</p><p>基准测试按照其测试用例是否接近于真实运行的环境，分为微基准测试（Micro-Benchmarking）、模拟、回放、工业标准(生产环境)测试。[2]</p><p><em>微基准测试</em> 使用人造的测试用例对某类特定的操作做测试。这类特定的操作往往指的是软件的一小部分(比如一个方法)。</p><p>这篇文章主要介绍的是微基准测试。</p><h1 id="基准测试应该注意的问题"><a class="markdownIt-Anchor" href="#基准测试应该注意的问题"></a> 基准测试应该注意的问题</h1><h2 id="基准测试不是随意的测试"><a class="markdownIt-Anchor" href="#基准测试不是随意的测试"></a> 基准测试不是随意的测试</h2><p>基准测试不是仅仅执行一下，记一下结果就可以的。比如常常出现的问题就是忽略缓存对于测试结果的影响。</p><p>好的基准测试应该检查以下几点：</p><ol><li>严格检查实际测试的是什么</li><li>确定理解测试了什么：对测试结果进行分析</li><li>得出有效的结论</li></ol><h2 id="控制变量的个数"><a class="markdownIt-Anchor" href="#控制变量的个数"></a> 控制变量的个数</h2><p>为保证得出正确的结论，控制不同的测试中除了被测试的变量，确保没有其他变量对结果造成影响。这个往往是比较难以达到的，比如对 Java 程序进行微基准测试，需要注意编译器优化(包括编译期优化和运行时优化 JIT)、机器负载、操作系统的缓存等等变量。做到这些需要使用合适的工具加上测试者对这些有一定的了解。</p><h2 id="基准测试的环境和配置"><a class="markdownIt-Anchor" href="#基准测试的环境和配置"></a> 基准测试的环境和配置</h2><p>基准测试之前，需尽力保证所测系统运行在最佳的系统和配置中，系统的性能以及达到真正的极限。比如”不服跑分“的测试中，确保被测手机的电量充足、系统没有开启省电模式等。</p><h1 id="java-中的微基准测试-jmh"><a class="markdownIt-Anchor" href="#java-中的微基准测试-jmh"></a> Java 中的微基准测试 JMH</h1><p>Java 官方提供了一个基准测试工具 <a href="https://openjdk.java.net/projects/code-tools/jmh/" rel="external nofollow noopener noreferrer" target="_blank">JMH</a>(Java Microbenchmark Harness)，我们可以用它测试</p><ol><li>一段代码平均执行多长时间</li><li>对比不同实现的性能</li></ol><h2 id="第一个微基准测试工程"><a class="markdownIt-Anchor" href="#第一个微基准测试工程"></a> 第一个微基准测试工程</h2><p>最为便捷的是使用 Maven 创建项目：</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">mvn archetype:generate \<br>          -DinteractiveMode=false \<br>          -DarchetypeGroupId=org.openjdk.jmh \<br>          -DarchetypeArtifactId=jmh-java-benchmark-archetype \<br>          -DgroupId=com.technologiesinsight.jmh \<br>          -DartifactId=jmh-demo \<br>          -Dversion=1.0<br></code></pre></td></tr></table></figure><p>构建完成后，会发现一个文件夹 jmh-demo。这是一个标准的 maven 工程，会有一个默认的测试类：MyBenchmark,位于 com.technologiesinsight.jmh 包下，也就是上面命令的 <code>-DgroupId</code> 填写的包名。测试类内容如下：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.technologiesinsight.jmh;<br><br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Benchmark;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBenchmark</span> </span>&#123;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// This is a demo/sample template for building your JMH benchmarks. Edit as needed.</span><br>        <span class="hljs-comment">// Put your benchmark code here.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，我们可以在 testMethod 填写基准测试代码。</p><p>这里以声明一个字符串举例：</p><figure class="hljs highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.Benchmark;<br><br><span class="hljs-comment">/***<br> *<br> * Benchmark                Mode  Cnt          Score         Error  Units<br> * MyBenchmark.testMethod  thrpt   25  217365928.196 ± 6111510.557  ops/s<br> *<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBenchmark</span> </span>&#123;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">testMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-string">"hello world"</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就可以运行了，进入项目目录，执行 <code>mvn clean package</code> 打包，执行 <code>java -jar target/benchmarks.jar</code> 运行,控制台会出现类似如下信息：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// 第一部分开始<br># JMH version: 1.21<br># VM version: JDK 1.8.0_201, Java HotSpot(TM) 64-Bit Server VM, 25.201-b09<br># VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home/jre/bin/java<br># VM options: -Dfile.encoding=UTF-8<br># Warmup: 5 iterations, 10 s each<br># Measurement: 5 iterations, 10 s each<br># Timeout: 10 min per iteration<br># Threads: 1 thread, will synchronize iterations<br># Benchmark mode: Throughput, ops/time<br># Benchmark: com.technologiesinsight.jmh.MyBenchmark.testMethod<br><br>// 第二部分开始<br># Run progress: 0.00% complete, ETA 00:08:20<br># Fork: 1 of 5<br># Warmup Iteration   1: 188758589.759 ops/s<br># Warmup Iteration   2: 187065201.979 ops/s<br># Warmup Iteration   3: 206670810.488 ops/s<br># Warmup Iteration   4: 211958028.465 ops/s<br># Warmup Iteration   5: 224040261.103 ops/s<br>Iteration   1: 224379265.753 ops/s<br>Iteration   2: 208679880.245 ops/s<br>Iteration   3: 206755976.374 ops/s<br>Iteration   4: 214591855.201 ops/s<br>Iteration   5: 219524929.562 ops/s<br>// ……此处省略迭代信息<br><br>// 第三部分开始<br>Result &quot;com.technologiesinsight.jmh.MyBenchmark.testMethod&quot;:<br>  217365928.196 ±(99.9%) 6111510.557 ops/s [Average]<br>  (min, avg, max) = (204122743.394, 217365928.196, 233217556.736), stdev = 8158691.742<br>  CI (99.9%): [211254417.640, 223477438.753] (assumes normal distribution)<br><br><br># Run complete. Total time: 00:08:22<br><br>REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on<br>why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial<br>experiments, perform baseline and negative tests that provide experimental control, make sure<br>the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.<br>Do not assume the numbers tell you what you want them to tell.<br><br>Benchmark                Mode  Cnt          Score         Error  Units<br>MyBenchmark.testMethod  thrpt   25  217365928.196 ± 6111510.557  ops/s<br></code></pre></td></tr></table></figure><p>输出信息可以分为三部分，使用 // 标注。第一部分是执行的环境、参数信息。第二分每次迭代的详情,第三部分是基准测试的结果。</p><p>我们着重看最后报告部分：</p><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Benchmark                Mode  Cnt          Score         Error  Units<br>MyBenchmark.testMethod  thrpt   25  217365928.196 ± 6111510.557  ops/s<br></code></pre></td></tr></table></figure><p>最重要的就是 <em>Score</em> 这一列，代表得分，单位是 <em>ops/s</em> 代表每秒钟可以执行多少次操作(其倒数就是平均运行一次测试用例需要多少时间)。因为赋值操作是十分轻量的操作，所以执行速度非常快，约为4.6纳秒就可以完成（未考虑测试框架本身微小的性能损耗）。</p><h1 id="关于jmh-的运行方式"><a class="markdownIt-Anchor" href="#关于jmh-的运行方式"></a> 关于JMH 的运行方式</h1><p>运行方式有多种，除了上面提到的使用命令行 java -jar 运行，也可以使用 IDEA 插件和 mian 方法运行。</p><ul><li>使用 <a href="https://plugins.jetbrains.com/plugin/7529-jmh-plugin" rel="external nofollow noopener noreferrer" target="_blank">IntelliJ IDEA 插件</a>：不需要写main 方法，也不需要打包，直接右键就可以运行。</li><li>使用 main 方法：不需要插件但需要写额外的 main 方法。 本系列的例子中提供了 helper 类方便的执行。</li></ul><p>下一篇文章将会详细介绍 JMH 的使用方式，以及提供<a href="https://github.com/KevinZhangMe/jmh-demo.git" rel="external nofollow noopener noreferrer" target="_blank">几个基准测试案例</a>，来验证几个提高性能的方法。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p>[1] 维基百科中对于基准测试的定义  <a href="https://en.wikipedia.org/wiki/Benchmark_(computing)" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Benchmark_(computing)</a></p><p>[2] Gregg, Brendan. Systems performance: enterprise and the cloud. Pearson Education, 2013. 中文译为 ”性能之巅“</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> JMH </tag>
            
            <tag> 基准测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas — 在线调试利器</title>
      <link href="/posts/5115/"/>
      <url>/posts/5115/</url>
      
        <content type="html"><![CDATA[<p>我们在开发中不难出现这样的问题：线上某个功能不可用，登上机器查看日志，发现在报错。但为什么报错，翻了半天日志可能也没找到原因，“日志”到用时方恨少，非常后悔当时没有多打日志。<br>此时，要么选择在线 Debug — 有时候并不那么容易；要么修改代码，增加相关日志打印语句，重新发布部署，而这容易导致问题难以复现。<br><a href="https://github.com/alibaba/arthas" rel="external nofollow noopener noreferrer" target="_blank">Arthas</a> 的出现解决了这样的困境。</p><a id="more"></a><p>Arthas(阿尔萨斯),它是由阿里开源的一款 Java 诊断工具，继承自 BTace 和 Greys,提供了 ：</p><ul><li>系统环境信息、虚拟机信息: (线程信息、内存信息、类加载信息)等的查看、监控。</li><li>运行时查看方法执行详情、方法调用链、方法调用统计信息。</li><li>提供内存中编译类、反编译加载的类、热加载类等功能</li></ul><p>更多详细功能请到<a href="https://alibaba.github.io/arthas/" rel="external nofollow noopener noreferrer" target="_blank">官方网站</a>查看。</p><h1 id="本系列文章的目的"><a class="markdownIt-Anchor" href="#本系列文章的目的"></a> 本系列文章的目的</h1><p>Arthas 中文文档写的十分详尽，此处不再做文档的搬运工。文章主要是对其做一些归类总结<br>在阅读下面的内容之前，请先了解 <a href="https://alibaba.github.io/arthas/commands.html" rel="external nofollow noopener noreferrer" target="_blank">官方命令列表</a></p><h1 id="命令分类"><a class="markdownIt-Anchor" href="#命令分类"></a> 命令分类</h1><p>使用 Arthas的第一步就是，熟练运用相关命令，活用相关命令，在真正出现线上问题，排查问题才能行云流水，一气呵成。下面对命令按照使用场景进行了分类分为：</p><ul><li><p>公共工具：sc、sm、stack</p></li><li><p>线上异常排查：watch、tt</p></li><li><p>动态代码执行: ognl</p></li><li><p>热更新: jad、mc、redefine、classloader、dump</p></li><li><p>性能分析：jvm、trace、thread</p></li><li><p><strong>彩蛋：</strong>：july、thanks</p></li></ul><h2 id="公共工具"><a class="markdownIt-Anchor" href="#公共工具"></a> 公共工具</h2><p>用于查找类、方法、方法调用栈。大多数命令使用前都需要知道类和方法，这些公共的工具提供了快速定位目标的方法(通过通配符或者正则表达式)</p><h2 id="线上异常排查"><a class="markdownIt-Anchor" href="#线上异常排查"></a> 线上异常排查</h2><p>线上排查问题的流程一般是：</p><ol><li><p>查看日志，找到具体报错异常栈和报错位置，也可以使用 sc,sm,stack 等工具找到方法调用入口，再使用 tt 或者 watch -e 查看异常栈和报错位置</p></li><li><p>查看方法调用细节，洞悉方法执行现场。</p><p>有两个选择：使用tt (TimeTunnel 时空隧道)，使用 watch</p><p><strong>tt 命令</strong></p><p>可以保存当前方法调用的详细信息，包括入参、返回值、异常信息（如果有的话），方便快速定位。也可以重放调用（但是不一定准确）</p><p><strong>watch 命令</strong></p><p>观察某个方法的详情，具体信息可以在后面跟表达式指定。例如: <code>watch demo.MathGame primeFactors &quot;{params,returnObj}&quot;</code>  可以查看参数，返回值。</p><p><strong>如何选择：</strong></p><p>tt 可以保存多个方法调用现场，方便后续查看、重放。但是有时候查看、重放不一定准确，原因是tt 只是保存当时环境的对象引用，当对象值改变之后，你查看的时候看到的是最新的值，而不是当时调用的值，这时，需要使用 watch 命令准确的查看方法调用的现场</p></li></ol><h2 id="动态代码执行"><a class="markdownIt-Anchor" href="#动态代码执行"></a> 动态代码执行</h2><p>上一步的异常排查发现出错位置和原因，如果仍然不知道如何修改，需要做一些探索，就需要动态代码执行工具了。Arthas 通过 ognl 表达式查看一些静态字段值，执行一些代码片段等。注意，getstatic 可以替代 ognl 查看类的静态字段的功能，但不建议学习，增加学习成本。</p><h2 id="热更新"><a class="markdownIt-Anchor" href="#热更新"></a> 热更新</h2><p>动态代码执行适合于执行一些表达式类短小精悍代码，对于大段代码就显得力不从心。于是就需要热更新技术了。<br>热更新工具箱包括 jad、mc、redefine、classloader、dump。热更新一段代码一般遵循一些顺序：</p><ol><li>反编译：使用jad 反编译已经加载的字节码，如果觉得反编译效果不好，可以使用 dump 转储字节码文件，然后使用其他工具反编译为代码。</li><li>修改代码：修改想要更新的代码</li><li>编译:可以使用 mc 命令编译更新的代码（需要指定class loader），也可以使用 idea 等第三方工具编译好，上传到服务器</li><li>加载新的类：使用 redfine 命令加载</li></ol><h3 id="redefine-使用限制"><a class="markdownIt-Anchor" href="#redefine-使用限制"></a> redefine 使用<strong>限制：</strong></h3><ul><li>不支持新增属性、方法</li><li>正在运行的函数 redefine 后不会生效，只有方法运行完后下次运行才会生效。</li></ul><h1 id="使用技巧"><a class="markdownIt-Anchor" href="#使用技巧"></a> 使用技巧</h1><h2 id="匹配多个方法"><a class="markdownIt-Anchor" href="#匹配多个方法"></a> 匹配多个方法</h2><p>如果想匹配多个方法，可以使用正则表达式，命令后面添加 -E 开启：</p><figure class="hljs highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">trace -E 'io\.netty\.channel\.nio\.NioEventLoop|io\.netty\.util\.concurrent\.SingleThreadEventExecutor'  'select|processSelectedKeys|runAllTasks' '@Thread@currentThread().getName().contains("IO-HTTP-WORKER-IOPool")&amp;&amp;#cost&gt;500'<br></code></pre></td></tr></table></figure><h2 id="退出-arthas"><a class="markdownIt-Anchor" href="#退出-arthas"></a> 退出 Arthas</h2><p>使用 exit/quit 命令结束当前回话，关闭客户端，但不会关闭服务端。使用 jps 查看，会看到Arthas 还在运行。需要使用 shutdown 命令完全关闭服务端。</p><h1 id="参考文档"><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h1><p>官方文档: <a href="https://alibaba.github.io/arthas/" rel="external nofollow noopener noreferrer" target="_blank">https://alibaba.github.io/arthas/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
            <tag> Arthas </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/hexo-admin-ehc-images.json"/>
      <url>/hexo-admin-ehc-images.json</url>
      
        <content type="html"><![CDATA[[{"name":"DASHENG-900x700-1.png","date":1518959551960},{"name":"DASHENG-900x700-2.png","date":1518959599098},{"name":"DASHENG-900x700-3.png","date":1518959609913},{"name":"DASHENG-900x700-4.png","date":1518959618105}]]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p><strong>科技洞见（<a href="http://technologiesinsight.com">technologiesinsight.com</a>）作者专注于Java、大数据相关领域。曾就职于去哪儿大数据部门；目前就职于快手数据平台，做大数据相关工作</strong></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
